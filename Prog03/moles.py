import curses
import time
import signal
import sys
import yaml
from threading import Thread, Lock, Semaphore
from curses import wrapper
from random import randrange, uniform

import numpy


def print_log(text):
    with open("game.log", "a") as file:
        file.write(time.strftime('%H:%M:%S') + ": " + text + "\n")


class Game():
    def __init__(self):
        config_file = open('config.yml')
        config = yaml.safe_load(config_file)
        config_file.close()

        # Rows in the gameboard
        self.rows = config['rows']

        # Columns in the gameboard
        self.columns = config['columns']

        if self.rows * self.columns > 26:
            print("Product of rows and columns must be <= 26")
            print("%d * %d > 26" % (self.rows, self.columns))
            sys.exit(1)

        # Max number of moles allowed to appear at a time
        self.max_number_of_moles = config['max_moles']

        if self.max_number_of_moles > self.rows * self.columns:
            print(
                "Max number of moles to appear on the board must be less than the product of rows and cells"
            )

        # Number of mole threads
        self.number_of_moles = config['mole_total']

        # Max amount of time the mole will appear
        self.popup_time_limit = config['pop_up_time'] / 1000

        # Max amount of time the mole will sleep
        self.sleep_time_limit = config['hide_time']

        self.locks = [[Lock() for _ in range(self.columns)]
                      for _ in range(self.rows)]

        # Handles the amount of moles in a game at once
        self.mole_semaphore = Semaphore(self.max_number_of_moles)

        # Thread handling each mole
        self.mole_threads = []

        # Array representation of gameboard
        # zero means no mole one means mole
        self.gameboard = numpy.zeros(
            (self.rows, self.columns)).astype('int').tolist()

        # game info
        self.attempts = 0
        self.score = 0
        self.missed = 0

    def run(self):
        self.game_is_running = True
        self.__spawn_threads()
        wrapper(self.__draw_screen)

    def __draw_screen(self, stdscr):
        """
        Render the gameboard in the terminal
        stdscr -- the screen generated by curses
        """
        print_log("Beginning screen rendering")
        # make stdscr.getch non-blocking
        stdscr.nodelay(True)
        stdscr.clear()
        while self.game_is_running:
            c = stdscr.getch()
            # set c to zero
            c -= 97
            row = c // (self.rows - 1)
            column = c % self.columns
            if row < 0 or column < 0:
                pass
            elif row < self.rows and column < self.columns:
                print_log("Hit attempted at %d, %d" % (row, column))
                mole_hit = self.__delete_mole(row, column)
                self.attempts += 1
                if mole_hit:
                    print_log("Mole hit!")
                    self.score += 1
                else:
                    self.missed += 1
            # Clear out anything else the user has typed in
            curses.flushinp()
            stdscr.clear()
            try:
                accuracy = self.score / self.attempts
            except ZeroDivisionError:
                accuracy = 0
            stdscr.addstr(self.__get_gameboard_string())
            stdscr.addstr("Score: %d\nMissed: %d\nAccuracy: %f\n" %
                          (self.score, self.missed, accuracy))
            stdscr.addstr("Ctrl+c (SIGINT) to quit")
            stdscr.refresh()
            time.sleep(1 / 60)

    def __get_gameboard_string(self):
        """
        Create the string to print out to the terminal
        """
        str = ""
        count = 0
        for row in self.gameboard:
            for item in row:
                if item is 1:
                    str += '{:4}'.format(chr(count + 97))
                else:
                    str += '    '
                count += 1
            str += '\n'
        return str

    def __mole_worker(self, mole):
        """
        Handles when a mole for the given thread popsup
        and when the mole for the given thread sleeps
        """
        print_log("Mole #%d worker created" % (mole))
        while self.game_is_running:
            sleep_time = uniform(0, self.sleep_time_limit)
            print_log("Mole #%d sleeping for %f seconds" % (mole, sleep_time))
            self.__mole_sleep(sleep_time)
            self.mole_semaphore.acquire()
            row, column = self.__add_random_mole()
            print_log("Added mole #%d at %d, %d" % (mole, row, column))

            popup_time = uniform(0, self.popup_time_limit)
            print_log("Mole #%d popping up for %f seconds" %
                      (mole, popup_time))
            self.__mole_popup(popup_time, row, column)
            self.__delete_mole(row, column)
            self.mole_semaphore.release()

    def __mole_sleep(self, sleep_time):
        """
        Waits for a given amount of time or for the game
        to be finished
        """
        timeout = time.time() + sleep_time
        while True:
            if not self.game_is_running or time.time() > timeout:
                break
            time.sleep(0.1)

    def __mole_popup(self, popup_time, row, column):
        """
        waits for a given amount of time, the cell to be cleared,
        or the game to be over
        """
        timeout = time.time() + popup_time
        while True:
            if not self.game_is_running or self.gameboard[row][
                    column] == 0 or time.time() > timeout:
                # sleep for one second before popping up again
                time.sleep(1)
                break
            time.sleep(0.1)

    def __delete_mole(self, row, column):
        """
        Set mole at the given cell to 0
        """
        with self.locks[row][column]:
            print_log("deleting mole at %d, %d" % (row, column))
            deleted = self.gameboard[row][column] == 1
            self.gameboard[row][column] = 0
        return deleted

    def __add_random_mole(self):
        """
        Make mole pop up in random board spot and stay there
        for a random duration
        """
        row = randrange(0, self.rows)
        column = randrange(0, self.columns)
        # pick a new spot in the gameboard until it isn't taken
        # already
        with self.locks[row][column]:
            while self.gameboard[row][column] is 1:
                row = randrange(0, self.rows)
                column = randrange(0, self.columns)
            self.gameboard[row][column] = 1
        return (row, column)

    def __spawn_threads(self):
        print_log("spawning mole threads")
        for x in range(self.number_of_moles):
            t = Thread(target=self.__mole_worker, args=(x, ))
            self.mole_threads.append(t)
            t.start()

    def stop(self):
        print_log("STOPPING GAME \n\n\n\n")
        self.game_is_running = False
        for t in self.mole_threads:
            t.join()
        print_log("Game is stopped")


if __name__ == "__main__":
    game = Game()

    def signal_handler(signal_num, frame):
        signal.signal(signal.SIGINT, lambda x: sys.exit())
        game.stop()
        sys.exit()

    signal.signal(signal.SIGINT, signal_handler)

    game.run()
